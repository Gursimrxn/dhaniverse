name: Deploy WebSocket Server to Azure

on:
  push:
    branches: [main]
    paths:
      - 'server/ws/**'
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Create deployment package
        run: |
          # Create a clean deployment directory
          mkdir -p deploy-ws
          
          # Copy WebSocket server files
          cp -r server/ws/* deploy-ws/
          
          # Remove any .env files from the deployment
          rm -f deploy-ws/.env*
          
          cd deploy-ws
          
          # Create package.json for Azure
          cat > package.json << 'EOF'
          {
            "name": "dhaniverse-ws",
            "version": "1.0.0",
            "description": "WebSocket server for Dhaniverse",
            "main": "index.js",
            "scripts": {
              "start": "node index.js"
            },
            "engines": {
              "node": ">=18.0.0"
            },
            "dependencies": {
              "ws": "^8.16.0"
            }
          }
          EOF
          
          # Create Node.js WebSocket server that proxies to Deno
          cat > index.js << 'EOF'
          const http = require('http');
          const https = require('https');
          const WebSocket = require('ws');
          const { spawn, execSync } = require('child_process');
          const fs = require('fs');
          const path = require('path');

          // Configuration
          const PORT = process.env.PORT || 8000;
          const DENO_ENV = process.env.DENO_ENV || 'development';
          const JWT_SECRET = process.env.JWT_SECRET || 'default-secret';
          const ALLOWED_ORIGINS = (process.env.ALLOWED_ORIGINS || '').split(',');
          const AUTH_SERVER_URL = process.env.AUTH_SERVER_URL || 'http://localhost:8000';
          const PRODUCTION_AUTH_SERVER_URL = process.env.PRODUCTION_AUTH_SERVER_URL || 'https://dhaniverseapi.deno.dev';

          // Create logs directory
          const logsDir = path.join(__dirname, 'logs');
          if (!fs.existsSync(logsDir)) {
            fs.mkdirSync(logsDir);
          }

          // Log file
          const logFile = path.join(logsDir, 'server.log');
          const logStream = fs.createWriteStream(logFile, { flags: 'a' });

          function log(message) {
            const timestamp = new Date().toISOString();
            const logMessage = `[${timestamp}] ${message}`;
            console.log(logMessage);
            logStream.write(logMessage + '\n');
          }

          // Install Deno
          async function installDeno() {
            try {
              log('Checking if Deno is installed...');
              
              try {
                execSync('deno --version', { stdio: 'pipe' });
                log('Deno is already installed');
                return true;
              } catch (err) {
                log('Deno is not installed. Installing...');
                
                // Download and install Deno
                const installScript = path.join(__dirname, 'install_deno.sh');
                
                // Create install script
                fs.writeFileSync(installScript, `
                  #!/bin/sh
                  curl -fsSL https://deno.land/x/install/install.sh | sh
                  echo 'export PATH="$HOME/.deno/bin:$PATH"' >> ~/.bashrc
                  export PATH="$HOME/.deno/bin:$PATH"
                `);
                
                // Make it executable
                fs.chmodSync(installScript, '755');
                
                // Run the install script
                execSync(`sh ${installScript}`, { stdio: 'inherit' });
                
                // Add Deno to PATH
                process.env.PATH = `${process.env.HOME}/.deno/bin:${process.env.PATH}`;
                
                try {
                  execSync('deno --version', { stdio: 'pipe' });
                  log('Deno installed successfully');
                  return true;
                } catch (err) {
                  log('Failed to verify Deno installation: ' + err.message);
                  return false;
                }
              }
            } catch (error) {
              log('Error installing Deno: ' + error.message);
              return false;
            }
          }

          // Create a simple WebSocket server
          const server = http.createServer((req, res) => {
            // Handle health check
            if (req.url === '/health') {
              res.writeHead(200, { 'Content-Type': 'application/json' });
              res.end(JSON.stringify({ status: 'ok', server: 'node-proxy' }));
              return;
            }
            
            // Default response
            res.writeHead(200, { 'Content-Type': 'text/plain' });
            res.end('WebSocket server is running. Connect with a WebSocket client.');
          });

          // Create WebSocket server
          const wss = new WebSocket.Server({ server });

          // Handle WebSocket connections
          wss.on('connection', (ws, req) => {
            log('WebSocket connection received');
            
            // Send a welcome message
            ws.send(JSON.stringify({
              type: 'info',
              message: 'Connected to WebSocket proxy server'
            }));
            
            // Handle messages
            ws.on('message', (message) => {
              try {
                const data = JSON.parse(message);
                log(`Received message: ${data.type}`);
                
                // Handle authentication
                if (data.type === 'authenticate') {
                  handleAuthentication(ws, data);
                } else {
                  // Echo back for now
                  ws.send(JSON.stringify({
                    type: 'echo',
                    message: 'Message received',
                    originalType: data.type
                  }));
                }
              } catch (error) {
                log(`Error handling message: ${error.message}`);
                ws.send(JSON.stringify({
                  type: 'error',
                  error: 'invalid_message',
                  message: 'Invalid message format'
                }));
              }
            });
            
            // Handle close
            ws.on('close', () => {
              log('WebSocket connection closed');
            });
            
            // Handle errors
            ws.on('error', (error) => {
              log(`WebSocket error: ${error.message}`);
            });
          });

          // Handle authentication
          async function handleAuthentication(ws, message) {
            try {
              log('Processing authentication request');
              
              // Get the auth server URL based on environment
              const authServerUrl = DENO_ENV === 'production'
                ? PRODUCTION_AUTH_SERVER_URL
                : AUTH_SERVER_URL;
              
              log(`Validating token with auth server: ${authServerUrl}`);
              
              // Make HTTP request to validate token
              const validateUrl = `${authServerUrl}/auth/validate-token`;
              
              // Determine if we need http or https
              const httpModule = authServerUrl.startsWith('https') ? https : http;
              
              const options = {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                }
              };
              
              const req = httpModule.request(validateUrl, options, (res) => {
                let data = '';
                
                res.on('data', (chunk) => {
                  data += chunk;
                });
                
                res.on('end', () => {
                  try {
                    const response = JSON.parse(data);
                    
                    if (res.statusCode === 200 && response.valid) {
                      // Authentication successful
                      log('Authentication successful');
                      
                      // Generate a unique ID for this connection
                      const connectionId = Date.now().toString(36) + Math.random().toString(36).substr(2);
                      
                      // Send connection confirmation
                      ws.send(JSON.stringify({
                        type: 'connect',
                        id: connectionId,
                        username: message.gameUsername || response.gameUsername
                      }));
                      
                      // Send empty players list
                      ws.send(JSON.stringify({
                        type: 'players',
                        players: []
                      }));
                    } else {
                      // Authentication failed
                      log('Authentication failed');
                      ws.send(JSON.stringify({
                        type: 'error',
                        error: 'authentication_failed',
                        message: 'Invalid token'
                      }));
                    }
                  } catch (error) {
                    log(`Error parsing authentication response: ${error.message}`);
                    ws.send(JSON.stringify({
                      type: 'error',
                      error: 'authentication_error',
                      message: 'Error processing authentication'
                    }));
                  }
                });
              });
              
              req.on('error', (error) => {
                log(`Error validating token: ${error.message}`);
                ws.send(JSON.stringify({
                  type: 'error',
                  error: 'authentication_error',
                  message: 'Error validating token'
                }));
              });
              
              // Send the token data
              req.write(JSON.stringify({ token: message.token }));
              req.end();
            } catch (error) {
              log(`Authentication error: ${error.message}`);
              ws.send(JSON.stringify({
                type: 'error',
                error: 'authentication_failed',
                message: 'Authentication failed'
              }));
            }
          }

          // Start the server
          server.listen(PORT, async () => {
            log(`WebSocket server listening on port ${PORT}`);
            log(`Environment: ${DENO_ENV}`);
            log(`Auth server URL: ${DENO_ENV === 'production' ? PRODUCTION_AUTH_SERVER_URL : AUTH_SERVER_URL}`);
            
            // Try to install Deno (but continue even if it fails)
            await installDeno();
          });

          // Handle process termination
          process.on('SIGTERM', () => {
            log('SIGTERM received, shutting down');
            server.close(() => {
              log('Server closed');
              process.exit(0);
            });
          });

          process.on('SIGINT', () => {
            log('SIGINT received, shutting down');
            server.close(() => {
              log('Server closed');
              process.exit(0);
            });
          });
          EOF
          
          # Install dependencies
          npm install ws
          
          # Create a simple HTML file for testing
          mkdir -p public
          cat > public/index.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
              <title>WebSocket Test</title>
              <style>
                  body { font-family: Arial, sans-serif; margin: 20px; }
                  #status { padding: 10px; border: 1px solid #ccc; margin-bottom: 10px; }
                  #log { height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; }
                  .success { color: green; }
                  .error { color: red; }
                  .info { color: blue; }
              </style>
          </head>
          <body>
              <h1>WebSocket Test</h1>
              <div id="status">Connecting...</div>
              <button id="connect">Connect</button>
              <button id="disconnect">Disconnect</button>
              <h2>Log</h2>
              <div id="log"></div>
              
              <script>
                  const status = document.getElementById('status');
                  const log = document.getElementById('log');
                  const connectBtn = document.getElementById('connect');
                  const disconnectBtn = document.getElementById('disconnect');
                  let ws = null;
                  
                  function addLog(message, type = 'info') {
                      const entry = document.createElement('div');
                      entry.className = type;
                      entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                      log.appendChild(entry);
                      log.scrollTop = log.scrollHeight;
                  }
                  
                  function connect() {
                      if (ws) {
                          addLog('Already connected', 'info');
                          return;
                      }
                      
                      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                      const wsUrl = `${protocol}//${window.location.host}`;
                      
                      addLog(`Connecting to ${wsUrl}...`, 'info');
                      status.textContent = 'Connecting...';
                      
                      ws = new WebSocket(wsUrl);
                      
                      ws.onopen = () => {
                          status.textContent = 'Connected!';
                          status.className = 'success';
                          addLog('Connected!', 'success');
                      };
                      
                      ws.onclose = () => {
                          status.textContent = 'Disconnected';
                          status.className = 'error';
                          addLog('Disconnected', 'error');
                          ws = null;
                      };
                      
                      ws.onerror = (error) => {
                          status.textContent = 'Error';
                          status.className = 'error';
                          addLog(`Error: ${error.message || 'Unknown error'}`, 'error');
                      };
                      
                      ws.onmessage = (event) => {
                          try {
                              const data = JSON.parse(event.data);
                              addLog(`Received: ${JSON.stringify(data)}`, 'info');
                          } catch (e) {
                              addLog(`Received: ${event.data}`, 'info');
                          }
                      };
                  }
                  
                  function disconnect() {
                      if (ws) {
                          ws.close();
                          ws = null;
                          status.textContent = 'Disconnected';
                          status.className = 'error';
                          addLog('Disconnected', 'info');
                      }
                  }
                  
                  connectBtn.addEventListener('click', connect);
                  disconnectBtn.addEventListener('click', disconnect);
                  
                  // Auto-connect on page load
                  connect();
              </script>
          </body>
          </html>
          EOF
          
          # Create web.config for Azure
          cat > web.config << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <configuration>
            <system.webServer>
              <webSocket enabled="true" />
              <handlers>
                <add name="iisnode" path="index.js" verb="*" modules="iisnode"/>
              </handlers>
              <rewrite>
                <rules>
                  <rule name="StaticContent">
                    <action type="Rewrite" url="public{REQUEST_URI}"/>
                  </rule>
                  <rule name="DynamicContent">
                    <conditions>
                      <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="True"/>
                    </conditions>
                    <action type="Rewrite" url="index.js"/>
                  </rule>
                </rules>
              </rewrite>
              <iisnode 
                nodeProcessCommandLine="node --max-http-header-size=16384"
                watchedFiles="*.js;iisnode.yml"
                loggingEnabled="true"
                logDirectory="iisnode"
                debuggingEnabled="false"
                maxLogFileSizeInKB="128"
                maxTotalLogFileSizeInKB="1024"
                maxLogFiles="20"
                devErrorsEnabled="false" />
            </system.webServer>
          </configuration>
          EOF
          
          # Create a zip file for deployment
          zip -r ../../ws-deploy.zip .

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v3
        with:
          app-name: 'dhaniverse-ws'
          slot-name: 'Production'
          package: ws-deploy.zip

      - name: Configure App Settings
        uses: azure/CLI@v1
        with:
          inlineScript: |
            az webapp config appsettings set --name dhaniverse-ws --resource-group dhaniverse-rg \
              --settings \
              DENO_ENV=production \
              JWT_SECRET="${{ secrets.JWT_SECRET }}" \
              ALLOWED_ORIGINS="https://dhaniverse.vercel.app" \
              AUTH_SERVER_URL="https://dhaniverseapi.deno.dev" \
              PRODUCTION_AUTH_SERVER_URL="https://dhaniverseapi.deno.dev" \
              WEBSITE_NODE_DEFAULT_VERSION="18.17.0" \
              SCM_DO_BUILD_DURING_DEPLOYMENT=false

      - name: Configure WebSocket Support
        uses: azure/CLI@v1
        with:
          inlineScript: |
            # Enable WebSockets
            az webapp config set --name dhaniverse-ws --resource-group dhaniverse-rg --web-sockets-enabled true
            
            # Set always on to keep the app running
            az webapp config set --name dhaniverse-ws --resource-group dhaniverse-rg --always-on true